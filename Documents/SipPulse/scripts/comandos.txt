Practical Packet analyses gfechio

tcpdump -nqt -s 0 -A -i eth1 port 5060
ngrep -d any -pqtW byline port 5060 or port 9060; 
{
    p → permite padrão como uma expressão regular compatível com linguagem Perl (PCRE)
    q → não escrever nada na saída padrãos56
    t → exibe o timestemp na primeira linha de cada pacote
    W→(maiúsculo) é de Word para selecionar palavras no pacote
    byline → quebra o pacote em uma linha para cada campo
    port →seleciona a porta que deseja capturar
}


ldd - print shared object dependencies
objdump -p /path/to/program | grep NEEDED

Tmux{
    
    
    Ctrl + B +... {
        % add +1 pane na  vertical
        " add +1 pane na horizontal
        $ renomeia pane
        z zoom foca na pane
        x fecha pane
        Arrows alterna entre panes
        Ctrl Arrow muda o tamanho da pane
        0..9 alterna entre windows
        
        z Minimiza sessão
        ? comandos        
    }

    tmux ls - lista as session
    tmux attach -t $s -> restaura a sessão aberta $s=numero sessao
    tmux kill-session -> fecha a sessao

}

grep -E "ens|inet"

Linux {
#verifica versão OS    
    cat /etc/redhat-release
    cat /etc/os-release
#Verifica se o serviço está rodando, procura pelo nome    
    ps -ef | grep cron
    ps -ef | grep opensips
#Tunel SSL para o rabbit/glassfish
    ssh -i suportepulse.pem -L15672:localhost:15672 suporte@IP_CLIENTE
    ssh -i suportepulse.pem -L4848:localhost:4848 suporte@IP_CLIENTE
        ssh -L PORTA_LOCAL:SERVER3:PORTA_FINAL USER_SERVER2@SERVER2  
#SCP  COMPLETAR
    scp -p porta -i chave.pem 
#Sistema de arquivos
    df -hT
        -h --human-readable
        -T  --print-type  tipo de filesystem
    efibootmgr 
        #manipula o gerenciador de boot do efi
#USUARIOS
    #Exibem os usuarios criados
        cat /etc/passwd
        awk -F: '{ print $1}' /etc/passwd
    #Exibe info de usuario e grupo
    id  $user
    groups $user
    #Adiciona usuário e grupo(prim) e GRUPO(sec)
    useradd -g $grupo  -G $sudoers,$docker $user

#OPERAÇÕES COM HORARIO/timezone
    timedatectl --help
#COMANDOS DE REDE
    nano /etc/network/interfaces
    netstat -tulpn 
    #exibe brief de ip colorido
    ip -c -4 -br a

#PROCURAR ARQUIVOS SO
    find / -name teste_vinea.wav
    updatedb & locate arquivos

#LISTAR PACOTES INSTALADOS
    /etc/yum.repos.d
    apt list --installed
    yum list installed
    yum search pkgname
    rpm -qpR pkgname # LISTA DEPENDENCIAS
    rpm -V/--verify pkg #VERIFICA INTEGRIDADE DOS ARQUIVOS DESDE A INStALAÇÃO


#Verificar utilização de disco
    sudo du -kchs *

#ADD TIMESTAMP history
echo 'HISTTIMEFORMAT="%d/%m/%y %T "' >> /home/suporte/.bashrc
echo 'HISTTIMEFORMAT="%d/%m/%y %T "' >> /root/.bashrc

#GIT
    git --help
    git help everyday
    git-init(1) to create a new repository.
    git-log(1) to see what happened.
    git-switch(1) and git-branch(1) to switch branches.
    git-add(1) to manage the index file.
    git-diff(1) and git-status(1) to see what you are in the middle of doing.
    git-commit(1) to advance the current branch.
    git-restore(1) to undo changes.
    git-merge(1) to merge between local branches.

    git-clone(1) from the upstream to prime your local repository.

    git-pull(1) and git-fetch(1) from "origin" to keep up-to-date with the upstream.

    git-push(1) to shared repository, if you adopt CVS style shared repository workflow.


    #COMMITA ALTERAÇÕES
    git commit -a/ commit -m  'commentario'
    #ENVIA ALTERACOES FEITAS PARA BRANCH INFORMADA
    git push origin  branch_fixes_4.7.8
    # clona branch especifica
    git clone -b <branchname> <remote-repo-url>
    #verifica as branchs
    git clone -a 
    #ADICIONA REPOSITORIO REMOTO
    git remote add repo_name('aka origin') repo_url
    #Mostra os remote daquele git
    git remote -v 



#VIM
    #file explorer
    :Lex
    #tabs
    #abri arquivos em abas
    vim -p file1 file2
    #abre arquivo de dentro do vim
    gf
    #move from tabs
    gt gT
    #dicionario
    zg - adiciona palavra ao dicionarioi
    zw - adiciona como palavra errada
    zug - desfaz o zg, [ zuw ]:
    #substitui todo foo por bar com confirmação
    :%s/foo/bar/gc
    #find delete tudo contendo profile
    :g/profile/d
    #deleta tudo que nao tem wan ou error ou fail
    :v/error\|warn\|fail/d
    #copia range
    :1,10y
    #conta ocorrencias
    :%s/pattern//gn
    #remove espaços 
    :%s/\s//g
    #abre o arquivo na linha x
    vim arquivo +nlinha
    echo "syn on
	  set term=screen-256color
          set ts=4
          set expandtab
          set softtabstop=4
          set shiftwidth=4
          set background=dark
          set encoding=UTF-8" > /root/.vimrc_new 

    echo "syn on
          set term=screen-256color
          set ts=4
          set expandtab
          set softtabstop=4
          set shiftwidth=4
          set background=dark
          set encoding=UTF-8" > /home/suporte/.vimrc


}

#sed
    #deleta toda match do arquivo(-i muda o arqquivo)
    sed -i '/pattern/d' arquivo.txt

#trunca arquivos com permissao de root
sudo truncate -s 0 /var/log/**/*.log
sudo sh -c '> filename'




#FREESWITCH
/usr/local/fs/scripts/facilitie


reloadxml não cai chamada
reload mod_dialplan_xml tb nao cai

reload sip_profile cai chamada


#verifica chamadas na fila do fs
callcenter_config queue list members [queue_name]
derruba chamada
uuid_kill uuid [cause]


ORIGINATE COMANDO DO FS QUE SIMULA CHAMADA
CHAMADO DA BLUE AUTENTICAR POR TCP OU MUDAR PARA PORTA 5070


fs.glassfish só em sbc
fs.fs nao é ideal
fs.nginx/apache 

fs_cli -x 'sofia loglevel all 9'

sofia global siptrace on
sofia global siptrace off

#chamada sem ringback

/etc/freeswitch/dialplan/default.xml
<condition field="${cc_queue}" expression="^.?$" break="never">
        <action application="set" data="ringback=$${us-ring}"/>
</condition>
reload mod_dialplan_xml


# Padrão quando fs failha pra subir
cd /usr/local/freeswitch/db
rm -rf *


pau no voicemail

cd /usr/local/freeswitch/sounds/pt/BR/karina/voicemail/
cd 16000
cp vm-delete_recording.wav vm-delete_recording.wav_old
cp vm-delete_message.wav vm-delete_recording.wav
depois repete pra cada pasta que tiver ali



menu_voicemail

If you then make a change to the directory you should run the xml_flush_cache command to clear, some examples:

# This clears items for user 1001
xml_flush_cache id 1002 domain-name

# This clears all items
xml_flush_cache 


echo 10 > /proc/sys/vm/swappiness

global_setvar cli_cache_3

eval ${cli_cache3}
,3137681467,3137681468,3137681469,3137681470,3137681471


CoreSession::setVariable(call_username, 7904)

switch_cpp.cpp:755 CoreSession::setVariable(effective_caller_id_name, Rafael Leite)


Glassfish - EAR
Payara - /opt/payara41
Freeswitch - /usr/local/freeswitch/scripts - /usr/local/freeswitch/scripts
Mysql - Dump de todas as databases
Nginx - /etc/nginx
Sippulse - /etc/sippulse
Audios - /var/lib/sippulse
Front end - /var/wwww
Docker (mesa telefonista e usr_registration)
Cron - /usr/local/bin/*.sh



chown -R glassfish.mysql /var/lib/sippulse 
chmod 775 /var/lib/sippulse

#lista dos arquivos do programa
lsof  /bin/binario 

#du com menuzinho
ncdu


